---
title: "Reglas de Asociación - S. Recomendación"
author: "Salvador Carrillo Fuentes"
date: "Abril de 2019"
output: html_document
css: style.css
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Análisis de relaciones entre canciones escuchadas en radio online

El *dataset* **lastfm.csv** del CV incluye las transacciones recogidas en una radio online que almacena el identificador del usuario, artista, sexo del usuario y el país.

**Objetivo**: Construir un sistema de recomendación de grupos de música a los usuarios a partir de dataset anterior.

```{r warning=FALSE}
library(arules)
library(readr)
lastfm <- read_csv("~/Grado Ingeniería Informática/G.I.I_2018/Segundo_cuatri/LabComp/Prácticas/Datasets/lastfm.csv")
lastfm[1:20,]
length(lastfm$user)   ## 289,955 filas
class(lastfm$user)
# Necesitamos convertir este atributo a factor
# para poder analizarlo con paquete {\tt arules}
lastfm$user <- factor(lastfm$user)
lastfm$artist <- factor(lastfm$artist)
# levels(lastfm$user)  ## 15,000 users
# levels(lastfm$artist)  ## 1,004 artists
```

Llamamos a `apriori()`:

```{r}
reglas1 <- apriori(lastfm, parameter=list(support=.01, confidence=.5))
inspect(reglas1)
```

*Comentario*: En versiones anteriores de *arules* el anterior comando daba error. Teníamos que convertir a factor las variables discretas. Es un paquete vivo que va evolucionando día a día.

**¿Cual es la recomendación que podemos obtener con estas reglas?**

No es el tipo de reglas que queremos obtener para nuestro sistema de recomendación.

Los datos deben ser manipulados para poder encontrar lo que nos interesa. Usaremos los Comandos: `split`, `lapply`.

Primero me quedo con una lista de lo que escucha cada usuario:

```{r}
lista.musica.por.usuario <- split(x=lastfm[,"artist"],f=lastfm$user)
lista.musica.por.usuario[1:2]
```

A continuación:

- Un grupo/cantante podría estar dos veces en un usuario: eliminar repeticiones
- Convertir a formato transacciones
- Mirar la música escuchada por los primeros usuarios

```{r}
# Eliminar duplicados  
lista.musica.por.usuario <- lapply(lista.musica.por.usuario,unique)

# Convertimos en transacciones la lista de música.
# lista.musica.por.usuario1 <- as(lista.musica.por.usuario,"transactions")

lista.musica.por.usuario[1:5]

# en la versión actual de R lo anterior va bien
# error ¿? (en versiones anteriores de R daba error, si os pasa, intentad los siguientes comandos)

lista.musica.por.usuario1 <- as(lapply(lista.musica.por.usuario, "[[", 1), "transactions")

lista.musica.por.usuario1
```

Visualizamos lo que hemos conseguido hasta el momento:

```{r}
str(lista.musica.por.usuario1)
write(head(lista.musica.por.usuario1))
write(head(lista.musica.por.usuario1),format="single")
```

Es una lista de transacciones - clase de datos definida en *arules*. Calculamos la frecuencia relativa de las canciones escuchadas:

```{r}
itfreq1  <-itemFrequency(lista.musica.por.usuario1)
head(itfreq1)
```

`itfreq1()`:

- es una vector numérico
- los nombres de la lista `names(itfreq)` - los nombres de cada grupo
- cada posición por tanto es la frecuencia del grupo de esa posición

```{r}
itfreq1[1]
```


Dibujar las frecuencias usando la lista de transacciones obtenida:

```{r}
itemFrequencyPlot(lista.musica.por.usuario1,support=.08,cex.names=1)
```

Y obtenemos las reglas de asociación con soporte 0.1 y confianza 0.5:

```{r}
reglas2 <- apriori(lista.musica.por.usuario1,parameter=
                     list(support=.01, confidence=.5))
reglas2
inspect(reglas2)
```

## Sistema de recomendación

Primero nos quedamos con las reglas más interesantes. Filtramos aquellas con *lift* mayor que 1:

```{r}
inspect(subset(reglas2, subset=lift > 1))
```

Ordenamos por confianza estas reglas anteriores:

```{r}
inspect(sort(subset(reglas2, subset=lift > 1), by="confidence"))
```

**¿Recomendación a usuarios que escuchan Coldplay?:**

```{r}
r1 <-subset(reglas2, subset = lhs %ain% 
         c("coldplay"))
inspect(r1)
# probar con otros grupos
```

